syntax = "proto3";
package flockpb;
option go_package = "github.com/jrife/flock/transport/flockpb";

// Model definitions only here (to be used by other transports)
import "github.com/coreos/etcd/raft/raftpb/raft.proto";
import "gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;
option (gogoproto.goproto_enum_prefix_all) = false;

// Controller Logic:
// 1) Create lease and peridically renew. (30 second TTL)
// 2) Try to create leader key with your lease ID.
// 3) If leader key has a different lease ID step down and stop control loop until another election when we might become leader
// 4) Each transaction has a guard ensuring that you're still the leader (check if leader key's lease field = your lease ID)
//    If the current leader doesn't know it has been replaced this guard ensures it cant effect change.
// Multiple controllers may attempt to become leader but only one will win
// Mapping this to a REST API:
// Lease:
//   id: 33
//   ttl: 30
//
// get lease
// claim lease
// renew lease
// reqlinquish lease
//
// POST /fencing-tokens { id: 123, ttl: 30, group: "abc" }
// create
// GET /fencing-tokens
// query
// DELETE /fencing-tokens/{id}
// delete
//
// Under the hood:
// Leases/<lease_id>
// Keys/FENCING_TOKENS/<lease_id> // just reuses the lease ID since it's a unique identifier
//   Lease: <lease_id>
// each key under /fencingtokens is tied to a lease and so its lifecycle is controlled by the lease
// but this layer of indirection allows us to use leases for other purposes later on rather than
// only having one layer (directly using leases to represent our fencing tokens)
// 
// GET /fencing-groups
// GET /fencing-groups/{name}
// { name: "abc", latest_token: 123 }
// 
// /fencing-groups/{name}
// 
// Other APIs:
// POST/PUT /partitions?fencing_group=<group>&fencing_token=<token_id>"
//
// Under the hood:
// Txn:
//    Conditions:
//       Domain: Key=FENCING_GROUPS/{group}
//       Quantifier: EXISTS
//       Predicate: LEASE={token_id}

service FencingTokens {
  // Query queries the collection of fencing tokens
  rpc Query(FencingTokensQueryRequest) returns (FencingTokensQueryResponse) {
    option (google.api.http) = {
      get: "/v1/fencing-tokens"
    };
  }

  // Create creates a fencing token
  rpc Create(FencingTokensCreateRequest) returns (FencingTokensCreateResponse) {
    option (google.api.http) = {
      post: "/v1/fencing-tokens"
      body: "*"
    };
  }

  // Renew renews a fencing token
  rpc Renew(FencingTokensRenewRequest) returns (FencingTokensRenewResponse) {
    option (google.api.http) = {
      post: "/v1/fencing-token/{id}/renewals"
      body: "*"
    };
  }

  // Delete revokes a fencing token
  rpc Delete(FencingTokensDeleteRequest) returns (FencingTokensDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/fencing-tokens/{id}"
    };
  }

  // Watch watches the collection of fencing tokens
  rpc Watch(FencingTokensWatchRequest) returns (FencingTokensWatchResponse) {
    option (google.api.http) = {
      post: "/v1/fencing-tokens-watchers"
      body: "*"
    };
  }
}

service FencingGroups {
  // Query queries the collection of fencing groups
  rpc Query(FencingGroupsQueryRequest) returns (FencingGroupsQueryResponse) {
    option (google.api.http) = {
      get: "/v1/fencing-groups"
    };
  }

  // Watch watches the collection of fencing groups
  rpc Watch(FencingGroupsWatchRequest) returns (FencingGroupsWatchResponse) {
    option (google.api.http) = {
      post: "/v1/fencing-groups-watchers"
      body: "*"
    };
  }
}

service StorageClasses {
  // Query queries the collection of storage classes
  rpc Query(StorageClassesQueryRequest) returns (StorageClassesQueryResponse) {
    option (google.api.http) = {
      get: "/v1/storage-classes"
    };
  }

  // Create registers a storage class
  rpc Create(StorageClassesCreateRequest) returns (StorageClassesCreateResponse) {
    option (google.api.http) = {
      post: "/v1/storage-classes"
      body: "*"
    };
  }

  // Update updates a storage class
  rpc Update(StorageClassesUpdateRequest) returns (StorageClassesUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/storage-classes/{id}"
      body: "*"
    };
  }

  // Delete deregisters a storage class
  rpc Delete(StorageClassesDeleteRequest) returns (StorageClassesDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/storage-classes/{id}"
    };
  }

  // Watch watches the collection of storage classes for changes
  rpc Watch(StorageClassesWatchRequest) returns (stream StorageClassesWatchResponse) {
    option (google.api.http) = {
      post: "/v1/storage-classes-watchers"
      body: "*"
    };
  }
}

service StorageHosts {
  // Query queries the collection of storage hosts
  rpc Query(StorageHostsQueryRequest) returns (StorageHostsQueryResponse) {
    option (google.api.http) = {
      get: "/v1/storage-hosts"
    };
  }

  // Create adds a storage host
  rpc Create(StorageHostsCreateRequest) returns (StorageHostsCreateResponse) {
    option (google.api.http) = {
      post: "/v1/storage-hosts"
      body: "*"
    };
  }

  // Update updates a storage host
  rpc Update(StorageHostsUpdateRequest) returns (StorageHostsUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/storage-hosts/{id}"
      body: "*"
    };
  }

  // Delete removes a storage host
  rpc Delete(StorageHostsDeleteRequest) returns (StorageHostsDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/storage-hosts/{id}"
    };
  }

  // Watch watches the collection of storage hosts for changes
  rpc Watch(StorageHostsWatchRequest) returns (stream StorageHostsWatchResponse) {
    option (google.api.http) = {
      post: "/v1/storage-hosts-watchers"
      body: "*"
    };
  }
}

service Stores {
  // Query queries the collection of stores
  rpc Query(StoresQueryRequest) returns (StoresQueryResponse) {
    option (google.api.http) = {
      get: "/v1/stores"
    };
  }

  // Create creates a store
  rpc Create(StoresCreateRequest) returns (StoresCreateResponse) {
    option (google.api.http) = {
      post: "/v1/stores"
      body: "*"
    };
  }

  // Update updates a store
  rpc Update(StoresUpdateRequest) returns (StoresUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/stores/{id}"
      body: "*"
    };
  }

  // Delete deletes a store
  rpc Delete(StoresDeleteRequest) returns (StoresDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/stores/{id}"
    };
  }

  // Watch watches the collection of stores for changes
  rpc Watch(StoresWatchRequest) returns (stream StoresWatchResponse) {
    option (google.api.http) = {
      post: "/v1/stores-watchers"
      body: "*"
    };
  }
}

service Partitions {
  // Query queries the collection of partitions
  rpc Query(PartitionsQueryRequest) returns (PartitionsQueryResponse) {
    option (google.api.http) = {
      get: "/v1/partitions"
    };
  }

  // Create creates a partition
  rpc Create(PartitionsCreateRequest) returns (PartitionsCreateResponse) {
    option (google.api.http) = {
      post: "/v1/partitions"
      body: "*"
    };
  }

  // Update updates a partition
  rpc Update(PartitionsUpdateRequest) returns (PartitionsUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/partitions/{id}"
      body: "*"
    };
  }

  // Delete deletes a partition
  rpc Delete(PartitionsDeleteRequest) returns (PartitionsDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/partitions/{id}"
    };
  }

  // Watch watches the collection of partitions for changes
  rpc Watch(PartitionsWatchRequest) returns (stream PartitionsWatchResponse) {
    option (google.api.http) = {
      post: "/v1/partitions-watchers"
      body: "*"
    };
  }
}

service Replicas {
  // Query queries the collection of replicas
  rpc Query(ReplicasQueryRequest) returns (ReplicasQueryResponse) {
    option (google.api.http) = {
      get: "/v1/replicas"
    };
  }

  // Create creates a replica
  rpc Create(ReplicasCreateRequest) returns (ReplicasCreateResponse) {
    option (google.api.http) = {
      post: "/v1/replicas"
      body: "*"
    };
  }

  // Update updates a replica
  rpc Update(ReplicasUpdateRequest) returns (ReplicasUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/replicas/{id}"
      body: "*"
    };
  }

  // Delete deletes a replica
  rpc Delete(ReplicasDeleteRequest) returns (ReplicasDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/replicas/{id}"
    };
  }

  // Watch watches the collection of replicas for changes
  rpc Watch(ReplicasWatchRequest) returns (stream ReplicasWatchResponse) {
    option (google.api.http) = {
      post: "/v1/replicas-watchers"
      body: "*"
    };
  }
}

service RaftGroups {
  // Query queries the collection of raft groups
  rpc Query(RaftGroupsQueryRequest) returns (RaftGroupsQueryResponse) {
    option (google.api.http) = {
      get: "/v1/raft-groups"
    };
  }

  // Create creates a raft group
  rpc Create(RaftGroupsCreateRequest) returns (RaftGroupsCreateResponse) {
    option (google.api.http) = {
      post: "/v1/raft-groups"
      body: "*"
    };
  }

  // Update updates a raft group
  rpc Update(RaftGroupsUpdateRequest) returns (RaftGroupsUpdateResponse) {
    option (google.api.http) = {
      put: "/v1/raft-groups/{id}"
      body: "*"
    };
  }

  // Delete deletes a raft group
  rpc Delete(RaftGroupsDeleteRequest) returns (RaftGroupsDeleteResponse) {
    option (google.api.http) = {
      delete: "/v1/raft-groups/{id}"
    };
  }

  // Watch watches the collection of raft groups for changes
  rpc Watch(RaftGroupsWatchRequest) returns (stream RaftGroupsWatchResponse) {
    option (google.api.http) = {
      post: "/v1/raft-groups-watchers"
      body: "*"
    };
  }
}

message Guard {
  string fencing_group = 1;
  int64 fencing_token = 2;
}

message WatchResponse {
  // Create, Update, Delete

}

message FencingTokensQueryRequest {
  string id = 1;
  string group = 2;
}

message FencingTokensQueryResponse {
  repeated FencingToken data = 1;
}

message FencingTokensCreateRequest {
  FencingToken token = 1;
}

message FencingTokensCreateResponse {
  FencingToken token = 1;
}

message FencingTokensRenewRequest {
  string id = 1;
}

message FencingTokensRenewResponse {
  FencingToken token = 1;
}

message FencingTokensDeleteRequest {
  string id = 1;
}

message FencingTokensDeleteResponse {
  FencingToken token = 1;
}

message FencingTokensWatchRequest {
}

message FencingTokensWatchResponse {
}

message FencingGroupsQueryRequest {
}

message FencingGroupsQueryResponse {
}

message FencingGroupsWatchRequest {
}

message FencingGroupsWatchResponse {
}

message StorageClassesQueryRequest {
  Guard guard = 1;
  string name = 2;
  int64 version = 3;
}

message StorageClassesQueryResponse {
  repeated StorageClass data = 1;
}

message StorageClassesCreateRequest {
  Guard guard = 1;
  StorageClass storage_class = 2;
}

message StorageClassesCreateResponse {
  StorageClass storage_class = 1;
}

message StorageClassesUpdateRequest {
  Guard guard = 1;
  StorageClass body = 2;
}

message StorageClassesUpdateResponse {
  StorageClass body = 1;
}

message StorageClassesDeleteRequest {
  Guard guard = 1;
  string name = 2;
}

message StorageClassesDeleteResponse {
  StorageClass body = 1;
}

message StorageClassesWatchRequest {
  Guard guard = 1;
}

message StorageClassesWatchResponse {
}

message StorageHostsQueryRequest {
  Guard guard = 1;
  string storage_classes = 2;
  bool raft_host = 3;
  string availability_zone = 4;
}

message StorageHostsQueryResponse {
  repeated StorageHost data = 1;
}

message StorageHostsCreateRequest {
  Guard guard = 1;
  StorageHost storage_host = 2;
}

message StorageHostsCreateResponse {
  StorageHost storage_host = 1;
}

message StorageHostsUpdateRequest {
  Guard guard = 1;
  StorageHost storage_host = 2;
}

message StorageHostsUpdateResponse {
  StorageHost storage_host = 1;
}

message StorageHostsDeleteRequest {
  Guard guard = 1;
  string name = 2;
}

message StorageHostsDeleteResponse {
  StorageHost storage_host = 1;
}

message StorageHostsWatchRequest {
  Guard guard = 1;
}

message StorageHostsWatchResponse {
}

message StoresQueryRequest {
  Guard guard = 1;
}

message StoresQueryResponse {
}

message StoresCreateRequest {
  Guard guard = 1;
}

message StoresCreateResponse {
}

message StoresUpdateRequest {
  Guard guard = 1;
}

message StoresUpdateResponse {
}

message StoresDeleteRequest {
  Guard guard = 1;
}

message StoresDeleteResponse {
}

message StoresWatchRequest {
  Guard guard = 1;
}

message StoresWatchResponse {
}

message PartitionsQueryRequest {
  Guard guard = 1;
}

message PartitionsQueryResponse {
}

message PartitionsCreateRequest {
  Guard guard = 1;
}

message PartitionsCreateResponse {
}

message PartitionsUpdateRequest {
  Guard guard = 1;
}

message PartitionsUpdateResponse {
}

message PartitionsDeleteRequest {
  Guard guard = 1;
}

message PartitionsDeleteResponse {
}

message PartitionsWatchRequest {
  Guard guard = 1;
}

message PartitionsWatchResponse {
}

message ReplicasQueryRequest {
  Guard guard = 1;
}

message ReplicasQueryResponse {
}

message ReplicasCreateRequest {
  Guard guard = 1;
}

message ReplicasCreateResponse {
}

message ReplicasUpdateRequest {
  Guard guard = 1;
}

message ReplicasUpdateResponse {
}

message ReplicasDeleteRequest {
  Guard guard = 1;
}

message ReplicasDeleteResponse {
}

message ReplicasWatchRequest {
  Guard guard = 1;
}

message ReplicasWatchResponse {
}

message RaftGroupsQueryRequest {
  Guard guard = 1;
}

message RaftGroupsQueryResponse {
}

message RaftGroupsCreateRequest {
  Guard guard = 1;
}

message RaftGroupsCreateResponse {
}

message RaftGroupsUpdateRequest {
  Guard guard = 1;
}

message RaftGroupsUpdateResponse {
}

message RaftGroupsDeleteRequest {
  Guard guard = 1;
}

message RaftGroupsDeleteResponse {
}

message RaftGroupsWatchRequest {
  Guard guard = 1;
}

message RaftGroupsWatchResponse {
}

message ObjectMetadata {
    string name = 1;
    map<string, string> labels = 2;
    int64 version = 3;
}

// First phase:
// Implement raft group scheduling
// Requires FencingToken, StorageHost, RaftGroup, RaftGroupReplica and associated services
message FencingToken {
  ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
  FencingTokenSpec spec = 2 [(gogoproto.nullable) = false];
  FencingTokenStatus status = 3 [(gogoproto.nullable) = false];
}

message FencingTokenSpec {
  int64 id = 1;
  int64 ttl = 2;
  string group = 3;
}

message FencingTokenStatus {
  string expires = 1;
}

message FencingGroup {
  ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
  FencingGroupSpec spec = 2 [(gogoproto.nullable) = false];
  FencingGroupStatus status = 3 [(gogoproto.nullable) = false];
}

message FencingGroupSpec {
  string name = 1;
}

message FencingGroupStatus {
  int64 token_id = 1;
}

message StorageClass {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    StorageClassSpec spec = 2 [(gogoproto.nullable) = false];
    StorageClassStatus status = 3 [(gogoproto.nullable) = false];
}

message StorageClassSpec {
}

message StorageClassStatus {
}

// Controllers use the storage hosts collection in their decision
// of where to place replicas
message StorageHost {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    StorageHostSpec spec = 2 [(gogoproto.nullable) = false];
    StorageHostStatus status = 3 [(gogoproto.nullable) = false];
}

message StorageHostSpec {
    // A list of storage classes that this host provides
    repeated string storage_classes = 1;
    // A flag indicating whether or not this host can host raft replicas
    bool raft_host = 2;
    // Putting this here so I remember. We should use labels for availability zone indication
    string availability_zone = 3;
}

message StorageHostStatus {
}

// Stores describe the specification for various
// distributed stores.
message Store {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    StoreSpec spec = 2 [(gogoproto.nullable) = false];
    StoreStatus status = 3 [(gogoproto.nullable) = false];
}

message StoreSpec {
    // A reference to the storage class that this store belongs
    // to
    string storage_class = 1;
    // How many replicas should each partition have
    uint32 replication_factor = 2;
}

message StoreStatus {
}

// Partitions describe a named partition of store. Each partition
// is linked to the raft group which forms the input for this
// partition.
message Partition {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    PartitionSpec spec = 2 [(gogoproto.nullable) = false];
    PartitionStatus status = 3 [(gogoproto.nullable) = false];
}

message PartitionSpec {
    // A reference to the store that this belongs to
    string store = 2;
    // A reference to the raft group that this is linked to
    string raft_group = 3;
    // The number of replicas for this partition.
    uint32 replication_factor = 4;
}

message PartitionStatus {
}

// Replicas are created by a flock controller in response to the creation of
// a partition. Each replica is linked to a raft group replica that forms
// the input for this replica.
message Replica {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    ReplicaSpec spec = 2 [(gogoproto.nullable) = false];
    ReplicaStatus status = 3 [(gogoproto.nullable) = false];
}

message ReplicaSpec {
    // A reference to the partition that this belongs to
    string partition = 1;
    // A reference to the raft group replica that this is linked to
    string raft_group_replica = 2;
    // A reference to the storage host where this replica should reside
    string storage_host = 3;
    string storage_class = 4;
}

message ReplicaStatus {
    // A reference to the storage host where this replica actually resides
    string storage_host = 1;
}

message RaftGroup {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    RaftGroupSpec spec = 2 [(gogoproto.nullable) = false];
    RaftGroupStatus status = 3 [(gogoproto.nullable) = false];
}

message RaftGroupSpec {
    // A reference to the partition that this raft group is linked to
    string partition = 1;
    // The number of replicas for this raft group
    uint32 replication_factor = 2;
}

message RaftGroupStatus {
}

message RaftGroupReplica {
    ObjectMetadata metadata = 1 [(gogoproto.nullable) = false];
    RaftGroupReplicaSpec spec = 2 [(gogoproto.nullable) = false];
    RaftGroupReplicaStatus status = 3 [(gogoproto.nullable) = false];
}

message RaftGroupReplicaSpec {
    // A reference to the raft group that this belongs to
    string raft_group = 1;
    // A reference to the replica that this is linked to
    string replica = 2;
    // A reference to the storage host where this replica resides
    string storage_host = 3;
}

message RaftGroupReplicaStatus {
}
